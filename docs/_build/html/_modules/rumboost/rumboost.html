<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>rumboost.rumboost &mdash; rumboost 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            rumboost
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">rumboost</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">rumboost</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">rumboost.rumboost</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for rumboost.rumboost</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="sd">&quot;&quot;&quot;Library with training routines of LightGBM.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">softmax</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">attrgetter</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">biogeme.biogeme</span> <span class="kn">import</span> <span class="n">BIOGEME</span>

<span class="kn">from</span> <span class="nn">lightgbm</span> <span class="kn">import</span> <span class="n">callback</span>
<span class="kn">from</span> <span class="nn">lightgbm.basic</span> <span class="kn">import</span> <span class="n">Booster</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">LightGBMError</span><span class="p">,</span> <span class="n">_ConfigAliases</span><span class="p">,</span> <span class="n">_InnerPredictor</span><span class="p">,</span> <span class="n">_choose_param_value</span><span class="p">,</span> <span class="n">_log_warning</span>
<span class="kn">from</span> <span class="nn">lightgbm.compat</span> <span class="kn">import</span> <span class="n">SKLEARN_INSTALLED</span><span class="p">,</span> <span class="n">_LGBMGroupKFold</span><span class="p">,</span> <span class="n">_LGBMStratifiedKFold</span>

<span class="kn">from</span> <span class="nn">rumboost.utils</span> <span class="kn">import</span> <span class="n">bio_to_rumboost</span>
<span class="kn">from</span> <span class="nn">rumboost.utility_smoothing</span> <span class="kn">import</span> <span class="n">stairs_to_pw</span>

<span class="n">_LGBM_CustomObjectiveFunction</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span>
    <span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Dataset</span><span class="p">],</span>
    <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span>
<span class="p">]</span>
<span class="n">_LGBM_CustomMetricFunction</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span>
    <span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Dataset</span><span class="p">],</span>
    <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span>
<span class="p">]</span>

<div class="viewcode-block" id="RUMBoost"><a class="viewcode-back" href="../../rumboost.html#rumboost.rumboost.RUMBoost">[docs]</a><span class="k">class</span> <span class="nc">RUMBoost</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;RUMBoost for doing Random Utility Modelling in LightGBM.</span>
<span class="sd">    </span>
<span class="sd">    Auxiliary data structure to implement boosters of ``rum_train()`` function for multiclass classification.</span>
<span class="sd">    This class has the same methods as Booster class.</span>
<span class="sd">    All method calls, except for the following methods, are actually performed for underlying Boosters.</span>

<span class="sd">    - ``model_from_string()``</span>
<span class="sd">    - ``model_to_string()``</span>
<span class="sd">    - ``save_model()``</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    boosters : list of Booster</span>
<span class="sd">        The list of underlying fitted models.</span>
<span class="sd">    valid_sets : None</span>
<span class="sd">        Validation sets of the RUMBoost. By default None, to avoid computing cross entropy if there are no </span>
<span class="sd">        validation sets.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_file</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the RUMBoost.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model_file : str, pathlib.Path or None, optional (default=None)</span>
<span class="sd">            Path to the RUMBoost model file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boosters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valid_sets</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">model_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">model_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_from_dict</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
    
<div class="viewcode-block" id="RUMBoost.f_obj"><a class="viewcode-back" href="../../rumboost.html#rumboost.rumboost.RUMBoost.f_obj">[docs]</a>    <span class="k">def</span> <span class="nf">f_obj</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">_</span><span class="p">,</span>
            <span class="n">train_set</span><span class="p">:</span> <span class="n">Dataset</span>
        <span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Objective function of the binary classification boosters, but based on softmax predictions.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            train_set : Dataset</span>
<span class="sd">                Training set used to train the jth booster. It means that it is not the full training set but rather another dataset containing the relevant features for that utility. It is the jth dataset in the RUMBoost object.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            grad : numpy array</span>
<span class="sd">                The gradient with the cross-entropy loss function. It is the predictions minus the binary labels (if it is used for the jth booster, labels will be 1 if the chosen class is j, 0 if it is any other classes).</span>
<span class="sd">            hess : numpy array</span>
<span class="sd">                The hessian with the cross-entropy loss function (second derivative approximation rather than the hessian). Calculated as factor * preds * (1 - preds).</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_j</span> <span class="c1">#jth booster</span>
            <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preds</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="c1">#corresponding predictions</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#factor to correct redundancy (see Friedmann, Greedy Function Approximation)</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-6</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">train_set</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">preds</span> <span class="o">-</span> <span class="n">labels</span>
            <span class="n">hess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="n">preds</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">preds</span><span class="p">),</span> <span class="n">eps</span><span class="p">)</span> <span class="c1">#truncate low values to avoid numerical errors</span>
            <span class="k">return</span> <span class="n">grad</span><span class="p">,</span> <span class="n">hess</span></div>
            
<div class="viewcode-block" id="RUMBoost.predict"><a class="viewcode-back" href="../../rumboost.html#rumboost.rumboost.RUMBoost.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">start_iteration</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">num_iteration</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">raw_score</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pred_leaf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">pred_contrib</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">data_has_header</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">validate_features</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">utilities</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">piece_wise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Predict logic.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : str, pathlib.Path, numpy array, pandas DataFrame, H2O DataTable&#39;s Frame or scipy.sparse</span>
<span class="sd">            Data source for prediction.</span>
<span class="sd">            If str or pathlib.Path, it represents the path to a text file (CSV, TSV, or LibSVM).</span>
<span class="sd">        start_iteration : int, optional (default=0)</span>
<span class="sd">            Start index of the iteration to predict.</span>
<span class="sd">        num_iteration : int, optional (default=-1)</span>
<span class="sd">            Iteration used for prediction.</span>
<span class="sd">        raw_score : bool, optional (default=False)</span>
<span class="sd">            Whether to predict raw scores.</span>
<span class="sd">        pred_leaf : bool, optional (default=False)</span>
<span class="sd">            Whether to predict leaf index.</span>
<span class="sd">        pred_contrib : bool, optional (default=False)</span>
<span class="sd">            Whether to predict feature contributions.</span>
<span class="sd">        data_has_header : bool, optional (default=False)</span>
<span class="sd">            Whether data has header.</span>
<span class="sd">            Used only for txt data.</span>
<span class="sd">        validate_features : bool, optional (default=False)</span>
<span class="sd">            If True, ensure that the features used to predict match the ones used to train.</span>
<span class="sd">            Used only if data is pandas DataFrame.</span>
<span class="sd">        utilities : bool, optional (default=True)</span>
<span class="sd">            If True, return raw utilities for each class, without generating probabilities.</span>
<span class="sd">        piece_wise : bool, optional (default=False)</span>
<span class="sd">            If True, use piece-wise utility instead of stairs utility.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : numpy array, scipy.sparse or list of scipy.sparse</span>
<span class="sd">            Prediction result.</span>
<span class="sd">            Can be sparse or a list of sparse objects (each element represents predictions for one class) for feature contributions (when ``pred_contrib=True``).</span>
<span class="sd">        &quot;&quot;&quot;</span>    
        <span class="c1">#compute utilities with corresponding features</span>
        <span class="k">if</span> <span class="n">piece_wise</span><span class="p">:</span> <span class="c1">#piece-wise utility</span>
            <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pw_predict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">utility</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#split data</span>
            <span class="n">new_data</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1">#compute U</span>
            <span class="n">U</span> <span class="o">=</span> <span class="p">[</span><span class="n">booster</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">new_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">get_data</span><span class="p">(),</span> 
                                 <span class="n">start_iteration</span><span class="p">,</span> 
                                 <span class="n">num_iteration</span><span class="p">,</span> 
                                 <span class="n">raw_score</span><span class="p">,</span> 
                                 <span class="n">pred_leaf</span><span class="p">,</span> 
                                 <span class="n">pred_contrib</span><span class="p">,</span>
                                 <span class="n">data_has_header</span><span class="p">,</span>
                                 <span class="n">validate_features</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">booster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boosters</span><span class="p">)]</span>

        <span class="n">preds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">U</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1">#softmax</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">utilities</span><span class="p">:</span>
            <span class="n">preds</span> <span class="o">=</span> <span class="n">softmax</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
   
        <span class="k">return</span> <span class="n">preds</span></div>
    
    <span class="k">def</span> <span class="nf">_inner_predict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_iteration</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">num_iteration</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">raw_score</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pred_leaf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">pred_contrib</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">data_has_header</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">validate_features</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">utilities</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">piece_wise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inner predict logic, the dataset is not assumed to be already build. Should not be used in public.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : str, pathlib.Path, numpy array, pandas DataFrame, H2O DataTable&#39;s Frame or scipy.sparse</span>
<span class="sd">            Data source for prediction.</span>
<span class="sd">            If str or pathlib.Path, it represents the path to a text file (CSV, TSV, or LibSVM).</span>
<span class="sd">        start_iteration : int, optional (default=0)</span>
<span class="sd">            Start index of the iteration to predict.</span>
<span class="sd">        num_iteration : int, optional (default=-1)</span>
<span class="sd">            Iteration used for prediction.</span>
<span class="sd">        raw_score : bool, optional (default=False)</span>
<span class="sd">            Whether to predict raw scores.</span>
<span class="sd">        pred_leaf : bool, optional (default=False)</span>
<span class="sd">            Whether to predict leaf index.</span>
<span class="sd">        pred_contrib : bool, optional (default=False)</span>
<span class="sd">            Whether to predict feature contributions.</span>
<span class="sd">        data_has_header : bool, optional (default=False)</span>
<span class="sd">            Whether data has header.</span>
<span class="sd">            Used only for txt data.</span>
<span class="sd">        validate_features : bool, optional (default=False)</span>
<span class="sd">            If True, ensure that the features used to predict match the ones used to train.</span>
<span class="sd">            Used only if data is pandas DataFrame.</span>
<span class="sd">        utilities : bool, optional (default=False)</span>
<span class="sd">            If True, return raw utilities for each class, without generating probabilities.     </span>
<span class="sd">        piece_wise : bool, optional (default=False)</span>
<span class="sd">            If True, use piece-wise utility instead of stairs utility.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : numpy array, scipy.sparse or list of scipy.sparse</span>
<span class="sd">            Prediction result.</span>
<span class="sd">            Can be sparse or a list of sparse objects (each element represents predictions for one class) for feature contributions (when ``pred_contrib=True``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#getting dataset</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_set</span>

        <span class="c1">#compute utilities with corresponding features</span>
        <span class="k">if</span> <span class="n">piece_wise</span><span class="p">:</span>
            <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pw_predict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">utility</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">U</span> <span class="o">=</span> <span class="p">[</span><span class="n">booster</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">get_data</span><span class="p">(),</span> 
                                 <span class="n">start_iteration</span><span class="p">,</span> 
                                 <span class="n">num_iteration</span><span class="p">,</span> 
                                 <span class="n">raw_score</span><span class="p">,</span> 
                                 <span class="n">pred_leaf</span><span class="p">,</span> 
                                 <span class="n">pred_contrib</span><span class="p">,</span>
                                 <span class="n">data_has_header</span><span class="p">,</span>
                                 <span class="n">validate_features</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">booster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boosters</span><span class="p">)]</span>

        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">U</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1">#softmax</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">utilities</span><span class="p">:</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">softmax</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">U</span>

<div class="viewcode-block" id="RUMBoost.pw_predict"><a class="viewcode-back" href="../../rumboost.html#rumboost.rumboost.RUMBoost.pw_predict">[docs]</a>    <span class="k">def</span> <span class="nf">pw_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">data_to_transform</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">utilities</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute predictions with piece-wise utility (WARNING: Not stable).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : Dataset</span>
<span class="sd">            The full training dataset.</span>
<span class="sd">        data_to_transform : pandas DataFrame, optional</span>
<span class="sd">            The stairs data to be transformed into a piece-wise linear approximation.</span>
<span class="sd">        utilities : bool, optional (default=False)</span>
<span class="sd">            If True, return raw utilities for each class, without generating probabilities.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        U : list or numpy array</span>
<span class="sd">            The piece-wise linear predictions</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#compute the piece-wise utilities</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">stairs_to_pw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_to_transform</span><span class="p">)</span>

        <span class="c1">#softmax</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">utilities</span><span class="p">:</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">softmax</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">U</span></div>
    
    <span class="k">def</span> <span class="nf">_preprocess_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">reduced_valid_set</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">return_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up J training (and, if specified, validation) datasets.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : Dataset</span>
<span class="sd">            The full training dataset (i.e. the union of the socio-economic features with the alternative-specific features).</span>
<span class="sd">        reduced_valid_set : Dataset or list of Dataset, optional (default = None)</span>
<span class="sd">            The full dataset used for validation. There can be several datasets.</span>
<span class="sd">        return_data : bool, optional (default = False)</span>
<span class="sd">            If True, returns the J preprocessed datasets (and potential validation sets)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        train_set_J : list[Dataset]</span>
<span class="sd">            If return_data is True, return a list with J preprocessed datasets corresponding to the J boosters.</span>
<span class="sd">        reduced_valid_sets_J : list[Dataset] or list[list[Dataset]], optional</span>
<span class="sd">            If return_data is True, and reduced_valid_set is not None, return one or several list(s) with J preprocessed validation sets corresponding to the J boosters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">train_set_J</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">reduced_valid_sets_J</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#to access data</span>
        <span class="n">data</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>

        <span class="c1">#loop over all J utilities</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">struct</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rum_structure</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">struct</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;columns&#39;</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                    <span class="n">train_set_j_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_data</span><span class="p">()[</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;columns&#39;</span><span class="p">]]</span> <span class="c1">#only relevant features for the jth booster</span>
                    <span class="n">new_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">#new binary label, used for multiclassification</span>
                    <span class="c1">#create and build dataset</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_linear_trees</span><span class="p">:</span>
                        <span class="n">train_set_j</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">train_set_j_data</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">new_label</span><span class="p">,</span> <span class="n">free_raw_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;linear_trees&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">})</span> <span class="c1">#WARNING not stable</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">train_set_j</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">train_set_j_data</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">new_label</span><span class="p">,</span> <span class="n">free_raw_data</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">train_set_j</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">reduced_valid_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">reduced_valid_sets_j</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">valid_set</span> <span class="ow">in</span> <span class="n">reduced_valid_set</span><span class="p">:</span>
                            <span class="c1">#create and build validation sets</span>
                            <span class="n">valid_set</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
                            <span class="n">valid_set_j_data</span> <span class="o">=</span> <span class="n">valid_set</span><span class="o">.</span><span class="n">get_data</span><span class="p">()[</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;columns&#39;</span><span class="p">]]</span> <span class="c1">#only relevant features for the j booster</span>
                            <span class="n">label_valid</span> <span class="o">=</span> <span class="n">valid_set</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span><span class="c1">#new binary label</span>
                            <span class="n">valid_set_j</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">valid_set_j_data</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label_valid</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span> <span class="n">train_set_j</span><span class="p">,</span> <span class="n">free_raw_data</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                            <span class="n">valid_set_j</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
                            <span class="n">reduced_valid_sets_j</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valid_set_j</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#if no alternative specific datasets</span>
                    <span class="n">train_set_j</span> <span class="o">=</span> <span class="n">data</span>
                    <span class="k">if</span> <span class="n">reduced_valid_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">reduced_valid_sets_j</span> <span class="o">=</span> <span class="n">reduced_valid_set</span><span class="p">[:]</span>

            <span class="c1">#store all training and potential validation sets in lists</span>
            <span class="n">train_set_J</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">train_set_j</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reduced_valid_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">reduced_valid_sets_J</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reduced_valid_sets_j</span><span class="p">)</span>

        <span class="c1">#store them in the RUMBoost object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_set</span> <span class="o">=</span> <span class="n">train_set_J</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valid_sets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reduced_valid_sets_J</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">return_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">train_set_J</span><span class="p">,</span> <span class="n">reduced_valid_sets_J</span>
    
    <span class="k">def</span> <span class="nf">_preprocess_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">return_params</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up J set of parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary containing parameters. The syntax must follow the one from LightGBM.</span>
<span class="sd">        return_params : bool, optional (default = False)</span>
<span class="sd">            If True, returns the J sets of parameters (and potential validation sets)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params_J : list[dict]</span>
<span class="sd">            A list of dictionary containing J sets of parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#store the number of classes in RUMBoost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;num_classes&#39;</span><span class="p">]</span>

        <span class="c1">#create the J parameters dictionaries</span>
        <span class="n">params_J</span> <span class="o">=</span> <span class="p">[{</span><span class="o">**</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">params</span><span class="p">),</span>
                    <span class="s1">&#39;objective&#39;</span><span class="p">:</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;num_classes&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s1">&#39;monotone_constraints&#39;</span><span class="p">:</span> <span class="n">struct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;monotone_constraints&#39;</span><span class="p">,</span> <span class="p">[])</span> <span class="k">if</span> <span class="n">struct</span> <span class="k">else</span> <span class="p">[],</span>
                    <span class="s1">&#39;interaction_constraints&#39;</span><span class="p">:</span> <span class="n">struct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;monotone_constraints&#39;</span><span class="p">,</span> <span class="p">[])</span> <span class="k">if</span> <span class="n">struct</span> <span class="k">else</span> <span class="p">[],</span>
                    <span class="s1">&#39;categorical_feature&#39;</span><span class="p">:</span> <span class="n">struct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;categorical_feature&#39;</span><span class="p">,</span> <span class="p">[])</span> <span class="k">if</span> <span class="n">struct</span> <span class="k">else</span> <span class="p">[]</span>
                    <span class="p">}</span> <span class="k">for</span> <span class="n">struct</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rum_structure</span><span class="p">]</span>
        
        <span class="c1">#update if with linear trees or not</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">with_linear_trees</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;linear_tree&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1">#store the set of parameters in RUMBoost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params_J</span>
        <span class="k">if</span> <span class="n">return_params</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">params_J</span>
        
    <span class="k">def</span> <span class="nf">_preprocess_valids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_set</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">valid_sets</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">valid_names</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare validation sets.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_set : Dataset</span>
<span class="sd">            The full training dataset (i.e. the union of the socio-economic features with the alternative-specific features).</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary containing parameters. The syntax must follow the one from LightGBM.</span>
<span class="sd">        valid_sets : Dataset or list[Dataset], optional (default = None)</span>
<span class="sd">            The full dataset used for validation. There can be several datasets.</span>
<span class="sd">        valid_names : str or list[str], optional (default = None)</span>
<span class="sd">            The names of the validation sets.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reduced_valid_sets : list[Dataset]</span>
<span class="sd">            List of prepared validation sets.</span>
<span class="sd">        name_valid_sets : list[str]</span>
<span class="sd">            List of names of validation sets.</span>
<span class="sd">        is_valid_contain_train: bool</span>
<span class="sd">            True if the training set is in the validation sets.</span>
<span class="sd">        train_data_name: str</span>
<span class="sd">            Name of training dataset : &#39;training&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#construct training set to access data</span>
        <span class="n">train_set</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>

        <span class="c1">#initialise variables</span>
        <span class="n">is_valid_contain_train</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">train_data_name</span> <span class="o">=</span> <span class="s2">&quot;training&quot;</span>
        <span class="n">reduced_valid_sets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">name_valid_sets</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#finalise validation sets for training</span>
        <span class="k">if</span> <span class="n">valid_sets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">valid_sets</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                <span class="n">valid_sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">valid_sets</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">valid_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">valid_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">valid_names</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">valid_data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">valid_sets</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">valid_data</span> <span class="ow">is</span> <span class="n">train_set</span><span class="p">:</span>
                    <span class="n">is_valid_contain_train</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1">#store if train set is in validation set</span>
                    <span class="k">if</span> <span class="n">valid_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">train_data_name</span> <span class="o">=</span> <span class="n">valid_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">valid_data</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Training only accepts Dataset object&quot;</span><span class="p">)</span>
                <span class="n">reduced_valid_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valid_data</span><span class="o">.</span><span class="n">_update_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">set_reference</span><span class="p">(</span><span class="n">train_set</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">valid_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">name_valid_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valid_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">name_valid_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;valid_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">reduced_valid_sets</span><span class="p">,</span> <span class="n">name_valid_sets</span><span class="p">,</span> <span class="n">is_valid_contain_train</span><span class="p">,</span> <span class="n">train_data_name</span>
        
    
    <span class="k">def</span> <span class="nf">_construct_boosters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_data_name</span> <span class="o">=</span> <span class="s2">&quot;Training&quot;</span><span class="p">,</span> <span class="n">is_valid_contain_train</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">name_valid_sets</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct boosters of the RUMBoost model with corresponding set of parameters, training datasets, and validation sets and store them in the RUMBoost object.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_data_name: str, optional (default = &#39;Training&#39;)</span>
<span class="sd">            Name of training dataset.</span>
<span class="sd">        is_valid_contain_train: bool</span>
<span class="sd">            True if the training set is in the validation sets.</span>
<span class="sd">        name_valid_sets : list[str]</span>
<span class="sd">            List of names of validation sets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#getting parameters, training, and validation sets</span>
        <span class="n">params_J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>
        <span class="n">train_set_J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_set</span>
        <span class="n">reduced_valid_sets_J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid_sets</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">param_j</span><span class="p">,</span> <span class="n">train_set_j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">params_J</span><span class="p">,</span> <span class="n">train_set_J</span><span class="p">)):</span>
            <span class="c1">#construct booster and perform basic preparations</span>
            <span class="k">try</span><span class="p">:</span> 
                <span class="n">booster</span> <span class="o">=</span> <span class="n">Booster</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">param_j</span><span class="p">,</span> <span class="n">train_set</span><span class="o">=</span><span class="n">train_set_j</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_valid_contain_train</span><span class="p">:</span>
                    <span class="n">booster</span><span class="o">.</span><span class="n">set_train_data_name</span><span class="p">(</span><span class="n">train_data_name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">valid_set</span><span class="p">,</span> <span class="n">name_valid_set</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">reduced_valid_sets_J</span><span class="p">,</span> <span class="n">name_valid_sets</span><span class="p">):</span>
                    <span class="n">booster</span><span class="o">.</span><span class="n">add_valid</span><span class="p">(</span><span class="n">valid_set</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">name_valid_set</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">train_set_j</span><span class="o">.</span><span class="n">_reverse_update_params</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">valid_set</span> <span class="ow">in</span> <span class="n">reduced_valid_sets_J</span><span class="p">:</span>
                    <span class="n">valid_set</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">_reverse_update_params</span><span class="p">()</span>
            
            <span class="c1">#initialise and store boosters in a list</span>
            <span class="n">booster</span><span class="o">.</span><span class="n">best_iteration</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_append</span><span class="p">(</span><span class="n">booster</span><span class="p">)</span>

        <span class="c1">#initialise RUMBoost score information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_iteration</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_score</span> <span class="o">=</span> <span class="mi">1000000</span>

    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">booster</span><span class="p">:</span> <span class="n">Booster</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a booster to RUMBoost.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boosters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">booster</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_from_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">models</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load RUMBoost from dict.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_iteration</span> <span class="o">=</span> <span class="n">models</span><span class="p">[</span><span class="s2">&quot;best_iteration&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_score</span> <span class="o">=</span> <span class="n">models</span><span class="p">[</span><span class="s2">&quot;best_score&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boosters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">model_str</span> <span class="ow">in</span> <span class="n">models</span><span class="p">[</span><span class="s2">&quot;boosters&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_append</span><span class="p">(</span><span class="n">Booster</span><span class="p">(</span><span class="n">model_str</span><span class="o">=</span><span class="n">model_str</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_iteration</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">start_iteration</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">importance_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Serialize RUMBoost to dict.&quot;&quot;&quot;</span>
        <span class="n">models_str</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">booster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boosters</span><span class="p">:</span>
            <span class="n">models_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">booster</span><span class="o">.</span><span class="n">model_to_string</span><span class="p">(</span><span class="n">num_iteration</span><span class="o">=</span><span class="n">num_iteration</span><span class="p">,</span> <span class="n">start_iteration</span><span class="o">=</span><span class="n">start_iteration</span><span class="p">,</span>
                                                      <span class="n">importance_type</span><span class="o">=</span><span class="n">importance_type</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;boosters&quot;</span><span class="p">:</span> <span class="n">models_str</span><span class="p">,</span> <span class="s2">&quot;best_iteration&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_iteration</span><span class="p">,</span> <span class="s2">&quot;best_score&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_score</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Redirect methods call of RUMBoost.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">handler_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Call methods with each booster, and concatenate their results.&quot;&quot;&quot;</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">booster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boosters</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">booster</span><span class="p">,</span> <span class="n">name</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">handler_function</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

<div class="viewcode-block" id="RUMBoost.model_from_string"><a class="viewcode-back" href="../../rumboost.html#rumboost.rumboost.RUMBoost.model_from_string">[docs]</a>    <span class="k">def</span> <span class="nf">model_from_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load RUMBoost from a string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model_str : str</span>
<span class="sd">            Model will be loaded from this string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : RUMBoost</span>
<span class="sd">            Loaded RUMBoost object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_from_dict</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">model_str</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="RUMBoost.model_to_string"><a class="viewcode-back" href="../../rumboost.html#rumboost.rumboost.RUMBoost.model_to_string">[docs]</a>    <span class="k">def</span> <span class="nf">model_to_string</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_iteration</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_iteration</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">importance_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;split&#39;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save RUMBoost to JSON string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num_iteration : int or None, optional (default=None)</span>
<span class="sd">            Index of the iteration that should be saved.</span>
<span class="sd">            If None, if the best iteration exists, it is saved; otherwise, all iterations are saved.</span>
<span class="sd">            If &lt;= 0, all iterations are saved.</span>
<span class="sd">        start_iteration : int, optional (default=0)</span>
<span class="sd">            Start index of the iteration that should be saved.</span>
<span class="sd">        importance_type : str, optional (default=&quot;split&quot;)</span>
<span class="sd">            What type of feature importance should be saved.</span>
<span class="sd">            If &quot;split&quot;, result contains numbers of times the feature is used in a model.</span>
<span class="sd">            If &quot;gain&quot;, result contains total gains of splits which use the feature.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str_repr : str</span>
<span class="sd">            JSON string representation of RUMBoost.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_dict</span><span class="p">(</span><span class="n">num_iteration</span><span class="p">,</span> <span class="n">start_iteration</span><span class="p">,</span> <span class="n">importance_type</span><span class="p">))</span></div>

<div class="viewcode-block" id="RUMBoost.save_model"><a class="viewcode-back" href="../../rumboost.html#rumboost.rumboost.RUMBoost.save_model">[docs]</a>    <span class="k">def</span> <span class="nf">save_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
        <span class="n">num_iteration</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_iteration</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">importance_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;split&#39;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;RUMBoost&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save RUMBoost to a file as JSON text.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str or pathlib.Path</span>
<span class="sd">            Filename to save RUMBoost.</span>
<span class="sd">        num_iteration : int or None, optional (default=None)</span>
<span class="sd">            Index of the iteration that should be saved.</span>
<span class="sd">            If None, if the best iteration exists, it is saved; otherwise, all iterations are saved.</span>
<span class="sd">            If &lt;= 0, all iterations are saved.</span>
<span class="sd">        start_iteration : int, optional (default=0)</span>
<span class="sd">            Start index of the iteration that should be saved.</span>
<span class="sd">        importance_type : str, optional (default=&quot;split&quot;)</span>
<span class="sd">            What type of feature importance should be saved.</span>
<span class="sd">            If &quot;split&quot;, result contains numbers of times the feature is used in a model.</span>
<span class="sd">            If &quot;gain&quot;, result contains total gains of splits which use the feature.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : RUMBoost</span>
<span class="sd">            Returns self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_dict</span><span class="p">(</span><span class="n">num_iteration</span><span class="p">,</span> <span class="n">start_iteration</span><span class="p">,</span> <span class="n">importance_type</span><span class="p">),</span> <span class="n">file</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div></div>

<div class="viewcode-block" id="rum_train"><a class="viewcode-back" href="../../rumboost.html#rumboost.rumboost.rum_train">[docs]</a><span class="k">def</span> <span class="nf">rum_train</span><span class="p">(</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">train_set</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span>
    <span class="n">rum_structure</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
    <span class="n">biogeme_model</span><span class="p">:</span> <span class="n">BIOGEME</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">num_boost_round</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">valid_sets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dataset</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">valid_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">feval</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">_LGBM_CustomMetricFunction</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">_LGBM_CustomMetricFunction</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">init_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">Booster</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">feature_name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span>
    <span class="n">categorical_feature</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span>
    <span class="n">keep_training_booster</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">callbacks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">pw_utility</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RUMBoost</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform the RUM training with given parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    params : dict</span>
<span class="sd">        Parameters for training. Values passed through ``params`` take precedence over those</span>
<span class="sd">        supplied via arguments.</span>
<span class="sd">    train_set : Dataset</span>
<span class="sd">        Data to be trained on.</span>
<span class="sd">    rum_structure : dict, optional (default=None)</span>
<span class="sd">        List of dictionaries specifying the RUM structure. </span>
<span class="sd">        The list must contain one dictionary for each class, which describes the </span>
<span class="sd">        utility structure for that class. </span>
<span class="sd">        Each dictionary has three allowed keys. </span>
<span class="sd">        &#39;cols&#39;: list of columns included in that class</span>
<span class="sd">        &#39;monotone_constraints&#39;: list of monotonic constraints on parameters</span>
<span class="sd">        &#39;interaction_constraints&#39;: list of interaction constraints on features</span>
<span class="sd">        if None, a biogeme_model must be specified</span>
<span class="sd">    biogeme_model : BIOGEME, optional (default=None)</span>
<span class="sd">        A BIOGEME object representing a biogeme model, used to create the rum_structure.</span>
<span class="sd">        A biogeme model is required if rum_structure is None, otherwise should be None.</span>
<span class="sd">    num_boost_round : int, optional (default=100)</span>
<span class="sd">        Number of boosting iterations.</span>
<span class="sd">    valid_sets : list of Dataset, or None, optional (default=None)</span>
<span class="sd">        List of data to be evaluated on during training.</span>
<span class="sd">    valid_names : list of str, or None, optional (default=None)</span>
<span class="sd">        Names of ``valid_sets``.</span>
<span class="sd">    feval : callable, list of callable, or None, optional (default=None)</span>
<span class="sd">        Customized evaluation function.</span>
<span class="sd">        Each evaluation function should accept two parameters: preds, eval_data,</span>
<span class="sd">        and return (eval_name, eval_result, is_higher_better) or list of such tuples.</span>

<span class="sd">            preds : numpy 1-D array or numpy 2-D array (for multi-class task)</span>
<span class="sd">                The predicted values.</span>
<span class="sd">                For multi-class task, preds are numpy 2-D array of shape = [n_samples, n_classes].</span>
<span class="sd">                If custom objective function is used, predicted values are returned before any transformation,</span>
<span class="sd">                e.g. they are raw margin instead of probability of positive class for binary task in this case.</span>
<span class="sd">            eval_data : Dataset</span>
<span class="sd">                A ``Dataset`` to evaluate.</span>
<span class="sd">            eval_name : str</span>
<span class="sd">                The name of evaluation function (without whitespaces).</span>
<span class="sd">            eval_result : float</span>
<span class="sd">                The eval result.</span>
<span class="sd">            is_higher_better : bool</span>
<span class="sd">                Is eval result higher better, e.g. AUC is ``is_higher_better``.</span>

<span class="sd">        To ignore the default metric corresponding to the used objective,</span>
<span class="sd">        set the ``metric`` parameter to the string ``&quot;None&quot;`` in ``params``.</span>
<span class="sd">    init_model : str, pathlib.Path, Booster or None, optional (default=None)</span>
<span class="sd">        Filename of LightGBM model or Booster instance used for continue training.</span>
<span class="sd">    feature_name : list of str, or &#39;auto&#39;, optional (default=&quot;auto&quot;)</span>
<span class="sd">        Feature names.</span>
<span class="sd">        If &#39;auto&#39; and data is pandas DataFrame, data columns names are used.</span>
<span class="sd">    categorical_feature : list of str or int, or &#39;auto&#39;, optional (default=&quot;auto&quot;)</span>
<span class="sd">        Categorical features.</span>
<span class="sd">        If list of int, interpreted as indices.</span>
<span class="sd">        If list of str, interpreted as feature names (need to specify ``feature_name`` as well).</span>
<span class="sd">        If &#39;auto&#39; and data is pandas DataFrame, pandas unordered categorical columns are used.</span>
<span class="sd">        All values in categorical features will be cast to int32 and thus should be less than int32 max value (2147483647).</span>
<span class="sd">        Large values could be memory consuming. Consider using consecutive integers starting from zero.</span>
<span class="sd">        All negative values in categorical features will be treated as missing values.</span>
<span class="sd">        The output cannot be monotonically constrained with respect to a categorical feature.</span>
<span class="sd">        Floating point numbers in categorical features will be rounded towards 0.</span>
<span class="sd">    keep_training_booster : bool, optional (default=False)</span>
<span class="sd">        Whether the returned Booster will be used to keep training.</span>
<span class="sd">        If False, the returned value will be converted into _InnerPredictor before returning.</span>
<span class="sd">        This means you won&#39;t be able to use ``eval``, ``eval_train`` or ``eval_valid`` methods of the returned Booster.</span>
<span class="sd">        When your model is very large and cause the memory error,</span>
<span class="sd">        you can try to set this param to ``True`` to avoid the model conversion performed during the internal call of ``model_to_string``.</span>
<span class="sd">        You can still use _InnerPredictor as ``init_model`` for future continue training.</span>
<span class="sd">    callbacks : list of callable, or None, optional (default=None)</span>
<span class="sd">        List of callback functions that are applied at each iteration.</span>
<span class="sd">        See Callbacks in Python API for more information.</span>
<span class="sd">    pw_utility: bool, optional (default=False)</span>
<span class="sd">        If true, compute continuous feature utility in a piece-wise linear way.</span>
<span class="sd">        </span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    A custom objective function can be provided for the ``objective`` parameter.</span>
<span class="sd">    It should accept two parameters: preds, train_data and return (grad, hess).</span>

<span class="sd">        preds : numpy 1-D array or numpy 2-D array (for multi-class task)</span>
<span class="sd">            The predicted values.</span>
<span class="sd">            Predicted values are returned before any transformation,</span>
<span class="sd">            e.g. they are raw margin instead of probability of positive class for binary task.</span>
<span class="sd">        train_data : Dataset</span>
<span class="sd">            The training dataset.</span>
<span class="sd">        grad : numpy 1-D array or numpy 2-D array (for multi-class task)</span>
<span class="sd">            The value of the first order derivative (gradient) of the loss</span>
<span class="sd">            with respect to the elements of preds for each sample point.</span>
<span class="sd">        hess : numpy 1-D array or numpy 2-D array (for multi-class task)</span>
<span class="sd">            The value of the second order derivative (Hessian) of the loss</span>
<span class="sd">            with respect to the elements of preds for each sample point.</span>

<span class="sd">    For multi-class task, preds are numpy 2-D array of shape = [n_samples, n_classes],</span>
<span class="sd">    and grad and hess should be returned in the same format.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rum_booster : RUMBoost</span>
<span class="sd">        The trained RUMBoost model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#create predictor first</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">_choose_param_value</span><span class="p">(</span>
        <span class="n">main_param_name</span><span class="o">=</span><span class="s1">&#39;objective&#39;</span><span class="p">,</span>
        <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
        <span class="n">default_value</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span>
    <span class="n">fobj</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_LGBM_CustomObjectiveFunction</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;objective&quot;</span><span class="p">]):</span>
        <span class="n">fobj</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;objective&quot;</span><span class="p">]</span>
        <span class="n">params</span><span class="p">[</span><span class="s2">&quot;objective&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
    <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">_ConfigAliases</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;num_iterations&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">num_boost_round</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
            <span class="n">_log_warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found `</span><span class="si">{</span><span class="n">alias</span><span class="si">}</span><span class="s2">` in params. Will use it instead of argument&quot;</span><span class="p">)</span>
    <span class="n">params</span><span class="p">[</span><span class="s2">&quot;num_iterations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_boost_round</span>
    <span class="c1">#setting early stopping via global params should be possible</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">_choose_param_value</span><span class="p">(</span>
        <span class="n">main_param_name</span><span class="o">=</span><span class="s2">&quot;early_stopping_round&quot;</span><span class="p">,</span>
        <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
        <span class="n">default_value</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;early_stopping_round&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;early_stopping_round&quot;</span><span class="p">)</span>
    <span class="n">first_metric_only</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;first_metric_only&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_boost_round</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_boost_round should be greater than zero.&quot;</span><span class="p">)</span>
    <span class="n">predictor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_InnerPredictor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_model</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">)):</span>
        <span class="n">predictor</span> <span class="o">=</span> <span class="n">_InnerPredictor</span><span class="p">(</span><span class="n">model_file</span><span class="o">=</span><span class="n">init_model</span><span class="p">,</span> <span class="n">pred_parameter</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_model</span><span class="p">,</span> <span class="n">Booster</span><span class="p">):</span>
        <span class="n">predictor</span> <span class="o">=</span> <span class="n">init_model</span><span class="o">.</span><span class="n">_to_predictor</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">init_model</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">))</span>
    <span class="n">init_iteration</span> <span class="o">=</span> <span class="n">predictor</span><span class="o">.</span><span class="n">num_total_iteration</span> <span class="k">if</span> <span class="n">predictor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="c1">#check dataset</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Training only accepts Dataset object&quot;</span><span class="p">)</span>

    <span class="n">train_set</span><span class="o">.</span><span class="n">_update_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> \
             <span class="o">.</span><span class="n">_set_predictor</span><span class="p">(</span><span class="n">predictor</span><span class="p">)</span> \
             <span class="o">.</span><span class="n">set_feature_name</span><span class="p">(</span><span class="n">feature_name</span><span class="p">)</span> \
             <span class="o">.</span><span class="n">set_categorical_feature</span><span class="p">(</span><span class="n">categorical_feature</span><span class="p">)</span>

    <span class="c1">#process callbacks</span>
    <span class="k">if</span> <span class="n">callbacks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">callbacks_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">callbacks</span><span class="p">):</span>
            <span class="n">cb</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">callbacks</span><span class="p">))</span>
        <span class="n">callbacks_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">callbacks</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;early_stopping_round&quot;</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
       <span class="n">callbacks_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
           <span class="n">callback</span><span class="o">.</span><span class="n">early_stopping</span><span class="p">(</span>
               <span class="n">stopping_rounds</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;early_stopping_round&quot;</span><span class="p">],</span>
               <span class="n">first_metric_only</span><span class="o">=</span><span class="n">first_metric_only</span><span class="p">,</span>
               <span class="n">verbose</span><span class="o">=</span><span class="n">_choose_param_value</span><span class="p">(</span>
                   <span class="n">main_param_name</span><span class="o">=</span><span class="s2">&quot;verbosity&quot;</span><span class="p">,</span>
                   <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                   <span class="n">default_value</span><span class="o">=</span><span class="mi">1</span>
               <span class="p">)</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;verbosity&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
           <span class="p">)</span>
       <span class="p">)</span>

    <span class="n">callbacks_before_iter_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">cb</span> <span class="k">for</span> <span class="n">cb</span> <span class="ow">in</span> <span class="n">callbacks_set</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="s1">&#39;before_iteration&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)}</span>
    <span class="n">callbacks_after_iter_set</span> <span class="o">=</span> <span class="n">callbacks_set</span> <span class="o">-</span> <span class="n">callbacks_before_iter_set</span>
    <span class="n">callbacks_before_iter</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">callbacks_before_iter_set</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">))</span>
    <span class="n">callbacks_after_iter</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">callbacks_after_iter_set</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">))</span>

    <span class="c1">#construct boosters</span>
    <span class="n">rum_booster</span> <span class="o">=</span> <span class="n">RUMBoost</span><span class="p">()</span>
    <span class="n">reduced_valid_sets</span><span class="p">,</span> \
    <span class="n">name_valid_sets</span><span class="p">,</span> \
    <span class="n">is_valid_contain_train</span><span class="p">,</span> \
    <span class="n">train_data_name</span> <span class="o">=</span> <span class="n">rum_booster</span><span class="o">.</span><span class="n">_preprocess_valids</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">valid_sets</span><span class="p">)</span> <span class="c1">#prepare validation sets</span>
    <span class="k">if</span> <span class="n">rum_structure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rum_booster</span><span class="o">.</span><span class="n">rum_structure</span> <span class="o">=</span> <span class="n">rum_structure</span> <span class="c1">#save utility structure</span>
    <span class="k">elif</span> <span class="n">biogeme_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rum_booster</span><span class="o">.</span><span class="n">rum_structure</span> <span class="o">=</span> <span class="n">bio_to_rumboost</span><span class="p">(</span><span class="n">biogeme_model</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either one of rum_structure or biogeme_model arguments must be passed&quot;</span><span class="p">)</span>
    <span class="n">rum_booster</span><span class="o">.</span><span class="n">_preprocess_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="c1">#prepare J set of parameters</span>
    <span class="n">rum_booster</span><span class="o">.</span><span class="n">_preprocess_data</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="n">reduced_valid_sets</span><span class="p">,</span> <span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#prepare J datasets with relevant features</span>
    <span class="n">rum_booster</span><span class="o">.</span><span class="n">_construct_boosters</span><span class="p">(</span><span class="n">train_data_name</span><span class="p">,</span> <span class="n">is_valid_contain_train</span><span class="p">,</span> <span class="n">name_valid_sets</span><span class="p">)</span> <span class="c1">#build boosters with corresponding params and dataset</span>

    <span class="c1">#initial prediction for first iteration</span>
    <span class="n">rum_booster</span><span class="o">.</span><span class="n">_preds</span> <span class="o">=</span> <span class="n">rum_booster</span><span class="o">.</span><span class="n">_inner_predict</span><span class="p">()</span>

    <span class="c1">#start training</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">init_iteration</span><span class="p">,</span> <span class="n">init_iteration</span> <span class="o">+</span> <span class="n">num_boost_round</span><span class="p">):</span>
        <span class="c1">#update all binary boosters of the rum_booster</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">booster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rum_booster</span><span class="o">.</span><span class="n">boosters</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">cb</span> <span class="ow">in</span> <span class="n">callbacks_before_iter</span><span class="p">:</span>
                <span class="n">cb</span><span class="p">(</span><span class="n">callback</span><span class="o">.</span><span class="n">CallbackEnv</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">booster</span><span class="p">,</span>
                                        <span class="n">params</span><span class="o">=</span><span class="n">rum_booster</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                                        <span class="n">iteration</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                                        <span class="n">begin_iteration</span><span class="o">=</span><span class="n">init_iteration</span><span class="p">,</span>
                                        <span class="n">end_iteration</span><span class="o">=</span><span class="n">init_iteration</span> <span class="o">+</span> <span class="n">num_boost_round</span><span class="p">,</span>
                                        <span class="n">evaluation_result_list</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>       
    
            <span class="c1">#update booster with custom binary objective function, and relevant features</span>
            <span class="n">rum_booster</span><span class="o">.</span><span class="n">_current_j</span> <span class="o">=</span> <span class="n">j</span>
            <span class="n">booster</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">train_set</span><span class="o">=</span><span class="n">rum_booster</span><span class="o">.</span><span class="n">train_set</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">fobj</span><span class="o">=</span><span class="n">rum_booster</span><span class="o">.</span><span class="n">f_obj</span><span class="p">)</span>
            
            <span class="c1">#check evaluation result. (from lightGBM initial code, check on all J binary boosters)</span>
            <span class="n">evaluation_result_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">valid_sets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_valid_contain_train</span><span class="p">:</span>
                    <span class="n">evaluation_result_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">booster</span><span class="o">.</span><span class="n">eval_train</span><span class="p">(</span><span class="n">feval</span><span class="p">))</span>
                <span class="n">evaluation_result_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">booster</span><span class="o">.</span><span class="n">eval_valid</span><span class="p">(</span><span class="n">feval</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">cb</span> <span class="ow">in</span> <span class="n">callbacks_after_iter</span><span class="p">:</span>
                    <span class="n">cb</span><span class="p">(</span><span class="n">callback</span><span class="o">.</span><span class="n">CallbackEnv</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">booster</span><span class="p">,</span>
                                            <span class="n">params</span><span class="o">=</span><span class="n">rum_booster</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                                            <span class="n">iteration</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                                            <span class="n">begin_iteration</span><span class="o">=</span><span class="n">init_iteration</span><span class="p">,</span>
                                            <span class="n">end_iteration</span><span class="o">=</span><span class="n">init_iteration</span> <span class="o">+</span> <span class="n">num_boost_round</span><span class="p">,</span>
                                            <span class="n">evaluation_result_list</span><span class="o">=</span><span class="n">evaluation_result_list</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">callback</span><span class="o">.</span><span class="n">EarlyStopException</span> <span class="k">as</span> <span class="n">earlyStopException</span><span class="p">:</span>
                <span class="n">booster</span><span class="o">.</span><span class="n">best_iteration</span> <span class="o">=</span> <span class="n">earlyStopException</span><span class="o">.</span><span class="n">best_iteration</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">evaluation_result_list</span> <span class="o">=</span> <span class="n">earlyStopException</span><span class="o">.</span><span class="n">best_score</span>

        <span class="c1">#make predictions after boosting round to compute new cross entropy and for next iteration grad and hess</span>
        <span class="n">rum_booster</span><span class="o">.</span><span class="n">_preds</span> <span class="o">=</span> <span class="n">rum_booster</span><span class="o">.</span><span class="n">_inner_predict</span><span class="p">(</span><span class="n">piece_wise</span><span class="o">=</span><span class="n">pw_utility</span><span class="p">)</span>
        <span class="c1">#compute cross validation on training or validation test</span>
        <span class="k">if</span> <span class="n">valid_sets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_valid_contain_train</span><span class="p">:</span>
                <span class="n">cross_entropy</span> <span class="o">=</span> <span class="n">rum_booster</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="n">rum_booster</span><span class="o">.</span><span class="n">_preds</span><span class="p">,</span> <span class="n">train_set</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">valid_set_J</span> <span class="ow">in</span> <span class="n">rum_booster</span><span class="o">.</span><span class="n">valid_sets</span><span class="p">:</span>
                    <span class="n">preds_valid</span> <span class="o">=</span> <span class="n">rum_booster</span><span class="o">.</span><span class="n">_inner_predict</span><span class="p">(</span><span class="n">valid_set_J</span><span class="p">,</span> <span class="n">piece_wise</span><span class="o">=</span><span class="n">pw_utility</span><span class="p">)</span>
                    <span class="n">cross_entropy_train</span> <span class="o">=</span> <span class="n">rum_booster</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="n">rum_booster</span><span class="o">.</span><span class="n">_preds</span><span class="p">,</span> <span class="n">train_set</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                    <span class="n">cross_entropy</span> <span class="o">=</span> <span class="n">rum_booster</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="n">preds_valid</span><span class="p">,</span> <span class="n">valid_set_J</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
        
            <span class="k">if</span> <span class="n">cross_entropy</span> <span class="o">&lt;</span> <span class="n">rum_booster</span><span class="o">.</span><span class="n">best_score</span><span class="p">:</span>
                <span class="n">rum_booster</span><span class="o">.</span><span class="n">best_score</span> <span class="o">=</span> <span class="n">cross_entropy</span>
                <span class="n">rum_booster</span><span class="o">.</span><span class="n">best_iteration</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        
            <span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbosity&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_valid_contain_train</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">{}</span><span class="s1">] -- NCE value on train set: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cross_entropy</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">{}</span><span class="s1">] -- NCE value on train set: </span><span class="si">{}</span><span class="s1"> </span><span class="se">\n</span><span class="s1">     --  NCE value on test set: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cross_entropy_train</span><span class="p">,</span> <span class="n">cross_entropy</span><span class="p">))</span>
        
        <span class="c1">#early stopping if early stopping criterion in all boosters</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;early_stopping_round&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">rum_booster</span><span class="o">.</span><span class="n">best_iteration</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;early_stopping_round&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Early stopping at iteration </span><span class="si">{}</span><span class="s1">, with a best score of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rum_booster</span><span class="o">.</span><span class="n">best_iteration</span><span class="p">,</span> <span class="n">rum_booster</span><span class="o">.</span><span class="n">best_score</span><span class="p">))</span>
            <span class="k">break</span>

    <span class="k">for</span> <span class="n">booster</span> <span class="ow">in</span> <span class="n">rum_booster</span><span class="o">.</span><span class="n">boosters</span><span class="p">:</span>
        <span class="n">booster</span><span class="o">.</span><span class="n">best_score</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dataset_name</span><span class="p">,</span> <span class="n">eval_name</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">evaluation_result_list</span><span class="p">:</span>
            <span class="n">booster</span><span class="o">.</span><span class="n">best_score</span><span class="p">[</span><span class="n">dataset_name</span><span class="p">][</span><span class="n">eval_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_training_booster</span><span class="p">:</span>
            <span class="n">booster</span><span class="o">.</span><span class="n">model_from_string</span><span class="p">(</span><span class="n">booster</span><span class="o">.</span><span class="n">model_to_string</span><span class="p">(),</span> <span class="n">verbose</span><span class="o">=</span><span class="s1">&#39;_silent_false&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">free_dataset</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">rum_booster</span></div>

<div class="viewcode-block" id="CVRUMBoost"><a class="viewcode-back" href="../../rumboost.html#rumboost.rumboost.CVRUMBoost">[docs]</a><span class="k">class</span> <span class="nc">CVRUMBoost</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;CVRUMBoost in LightGBM.</span>

<span class="sd">    Auxiliary data structure to hold and redirect all boosters of ``cv`` function.</span>
<span class="sd">    This class has the same methods as Booster class.</span>
<span class="sd">    All method calls are actually performed for underlying Boosters and then all returned results are returned in a list.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    rum_boosters : list of RUMBoost</span>
<span class="sd">        The list of underlying fitted models.</span>
<span class="sd">    best_iteration : int</span>
<span class="sd">        The best iteration of fitted model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the CVBooster.</span>

<span class="sd">        Generally, no need to instantiate manually.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RUMBoosts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_iteration</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_score</span> <span class="o">=</span> <span class="mi">100000</span>

    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rum_booster</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a booster to CVBooster.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RUMBoosts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rum_booster</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Redirect methods call of CVBooster.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">handler_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Call methods with each booster, and concatenate their results.&quot;&quot;&quot;</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">rum_booster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RUMBoosts</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">booster</span> <span class="ow">in</span> <span class="n">rum_booster</span><span class="p">:</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">booster</span><span class="p">,</span> <span class="n">name</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">handler_function</span></div>


<span class="k">def</span> <span class="nf">_make_n_folds</span><span class="p">(</span><span class="n">full_data</span><span class="p">,</span> <span class="n">folds</span><span class="p">,</span> <span class="n">nfold</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">fpreproc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stratified</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eval_train_metric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rum_structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">biogeme_model</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a n-fold list of Booster from random indices.&quot;&quot;&quot;</span>
    <span class="n">full_data</span> <span class="o">=</span> <span class="n">full_data</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
    <span class="n">num_data</span> <span class="o">=</span> <span class="n">full_data</span><span class="o">.</span><span class="n">num_data</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">folds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">folds</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">folds</span><span class="p">,</span> <span class="s1">&#39;split&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;folds should be a generator or iterator of (train_idx, test_idx) tuples &quot;</span>
                                 <span class="s2">&quot;or scikit-learn splitter object with split method&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">folds</span><span class="p">,</span> <span class="s1">&#39;split&#39;</span><span class="p">):</span>
            <span class="n">group_info</span> <span class="o">=</span> <span class="n">full_data</span><span class="o">.</span><span class="n">get_group</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">group_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">group_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">group_info</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">flatted_group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_info</span><span class="p">)),</span> <span class="n">repeats</span><span class="o">=</span><span class="n">group_info</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flatted_group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">folds</span> <span class="o">=</span> <span class="n">folds</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_data</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="n">full_data</span><span class="o">.</span><span class="n">get_label</span><span class="p">(),</span> <span class="n">groups</span><span class="o">=</span><span class="n">flatted_group</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">obj_alias</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;lambdarank&quot;</span><span class="p">,</span> <span class="s2">&quot;rank_xendcg&quot;</span><span class="p">,</span> <span class="s2">&quot;xendcg&quot;</span><span class="p">,</span>
                                             <span class="s2">&quot;xe_ndcg&quot;</span><span class="p">,</span> <span class="s2">&quot;xe_ndcg_mart&quot;</span><span class="p">,</span> <span class="s2">&quot;xendcg_mart&quot;</span><span class="p">}</span>
               <span class="k">for</span> <span class="n">obj_alias</span> <span class="ow">in</span> <span class="n">_ConfigAliases</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;objective&quot;</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">SKLEARN_INSTALLED</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">LightGBMError</span><span class="p">(</span><span class="s1">&#39;scikit-learn is required for ranking cv&#39;</span><span class="p">)</span>
            <span class="c1"># ranking task, split according to groups</span>
            <span class="n">group_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">full_data</span><span class="o">.</span><span class="n">get_group</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">flatted_group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_info</span><span class="p">)),</span> <span class="n">repeats</span><span class="o">=</span><span class="n">group_info</span><span class="p">)</span>
            <span class="n">group_kfold</span> <span class="o">=</span> <span class="n">_LGBMGroupKFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="n">nfold</span><span class="p">)</span>
            <span class="n">folds</span> <span class="o">=</span> <span class="n">group_kfold</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_data</span><span class="p">),</span> <span class="n">groups</span><span class="o">=</span><span class="n">flatted_group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">stratified</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">SKLEARN_INSTALLED</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">LightGBMError</span><span class="p">(</span><span class="s1">&#39;scikit-learn is required for stratified cv&#39;</span><span class="p">)</span>
            <span class="n">skf</span> <span class="o">=</span> <span class="n">_LGBMStratifiedKFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="n">nfold</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">folds</span> <span class="o">=</span> <span class="n">skf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_data</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="n">full_data</span><span class="o">.</span><span class="n">get_label</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
                <span class="n">randidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">num_data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">randidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_data</span><span class="p">)</span>
            <span class="n">kstep</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_data</span> <span class="o">/</span> <span class="n">nfold</span><span class="p">)</span>
            <span class="n">test_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">randidx</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">kstep</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_data</span><span class="p">,</span> <span class="n">kstep</span><span class="p">)]</span>
            <span class="n">train_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">test_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfold</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfold</span><span class="p">)]</span>
            <span class="n">folds</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">train_id</span><span class="p">,</span> <span class="n">test_id</span><span class="p">)</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">CVRUMBoost</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">train_idx</span><span class="p">,</span> <span class="n">test_idx</span> <span class="ow">in</span> <span class="n">folds</span><span class="p">:</span>
        <span class="n">train_set</span> <span class="o">=</span> <span class="n">full_data</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">train_idx</span><span class="p">))</span>
        <span class="n">valid_set</span> <span class="o">=</span> <span class="n">full_data</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">test_idx</span><span class="p">))</span>
        <span class="c1"># run preprocessing on the data set if needed</span>
        <span class="k">if</span> <span class="n">fpreproc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">train_set</span><span class="p">,</span> <span class="n">valid_set</span><span class="p">,</span> <span class="n">tparam</span> <span class="o">=</span> <span class="n">fpreproc</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="n">valid_set</span><span class="p">,</span> <span class="n">params</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tparam</span> <span class="o">=</span> <span class="n">params</span>
        <span class="c1">#create RUMBoosts with corresponding training, validation, and parameters sets</span>
        <span class="n">cvbooster</span> <span class="o">=</span> <span class="n">RUMBoost</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">rum_structure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cvbooster</span><span class="o">.</span><span class="n">rum_structure</span> <span class="o">=</span> <span class="n">rum_structure</span> <span class="c1">#save utility structure</span>
        <span class="k">elif</span> <span class="n">biogeme_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cvbooster</span><span class="o">.</span><span class="n">rum_structure</span> <span class="o">=</span> <span class="n">bio_to_rumboost</span><span class="p">(</span><span class="n">biogeme_model</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;max_depth&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either one of rum_structure or biogeme_model arguments must be passed&quot;</span><span class="p">)</span>
        <span class="n">reduced_valid_sets</span><span class="p">,</span> <span class="n">name_valid_sets</span><span class="p">,</span> <span class="n">is_valid_contain_train</span><span class="p">,</span> <span class="n">train_data_name</span> <span class="o">=</span> <span class="n">cvbooster</span><span class="o">.</span><span class="n">_preprocess_valids</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">valid_set</span><span class="p">)</span>
        <span class="n">cvbooster</span><span class="o">.</span><span class="n">_preprocess_data</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="n">reduced_valid_sets</span><span class="p">)</span>
        <span class="n">cvbooster</span><span class="o">.</span><span class="n">_preprocess_params</span><span class="p">(</span><span class="n">tparam</span><span class="p">)</span>
        <span class="n">cvbooster</span><span class="o">.</span><span class="n">_construct_boosters</span><span class="p">(</span><span class="n">train_data_name</span><span class="p">,</span> <span class="n">is_valid_contain_train</span><span class="p">,</span>
                                      <span class="n">name_valid_sets</span><span class="o">=</span><span class="n">name_valid_sets</span><span class="p">)</span>

        <span class="n">ret</span><span class="o">.</span><span class="n">_append</span><span class="p">(</span><span class="n">cvbooster</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ret</span>

<span class="k">def</span> <span class="nf">_agg_cv_result</span><span class="p">(</span><span class="n">raw_results</span><span class="p">,</span> <span class="n">eval_train_metric</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Aggregate cross-validation results.&quot;&quot;&quot;</span>
    <span class="n">cvmap</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
    <span class="n">metric_type</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">one_result</span> <span class="ow">in</span> <span class="n">raw_results</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">one_line</span> <span class="ow">in</span> <span class="n">one_result</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eval_train_metric</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">one_line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">one_line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">one_line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">metric_type</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">one_line</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">cvmap</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">cvmap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">one_line</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">[(</span><span class="s1">&#39;cv_agg&#39;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">metric_type</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cvmap</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>


<div class="viewcode-block" id="rum_cv"><a class="viewcode-back" href="../../rumboost.html#rumboost.rumboost.rum_cv">[docs]</a><span class="k">def</span> <span class="nf">rum_cv</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">train_set</span><span class="p">,</span> <span class="n">num_boost_round</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
       <span class="n">folds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nfold</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stratified</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
       <span class="n">metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fobj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">feval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
       <span class="n">feature_name</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">categorical_feature</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
       <span class="n">early_stopping_rounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fpreproc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
       <span class="n">verbose_eval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_stdv</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
       <span class="n">callbacks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eval_train_metric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
       <span class="n">return_cvbooster</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rum_structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
       <span class="n">biogeme_model</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform the cross-validation with given parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    params : dict</span>
<span class="sd">        Parameters for Booster.</span>
<span class="sd">    train_set : Dataset</span>
<span class="sd">        Data to be trained on.</span>
<span class="sd">    num_boost_round : int, optional (default=100)</span>
<span class="sd">        Number of boosting iterations.</span>
<span class="sd">    folds : generator or iterator of (train_idx, test_idx) tuples, scikit-learn splitter object or None, optional (default=None)</span>
<span class="sd">        If generator or iterator, it should yield the train and test indices for each fold.</span>
<span class="sd">        If object, it should be one of the scikit-learn splitter classes</span>
<span class="sd">        (https://scikit-learn.org/stable/modules/classes.html#splitter-classes)</span>
<span class="sd">        and have ``split`` method.</span>
<span class="sd">        This argument has highest priority over other data split arguments.</span>
<span class="sd">    nfold : int, optional (default=5)</span>
<span class="sd">        Number of folds in CV.</span>
<span class="sd">    stratified : bool, optional (default=True)</span>
<span class="sd">        Whether to perform stratified sampling.</span>
<span class="sd">    shuffle : bool, optional (default=True)</span>
<span class="sd">        Whether to shuffle before splitting data.</span>
<span class="sd">    metrics : str, list of str, or None, optional (default=None)</span>
<span class="sd">        Evaluation metrics to be monitored while CV.</span>
<span class="sd">        If not None, the metric in ``params`` will be overridden.</span>
<span class="sd">    fobj : callable or None, optional (default=None)</span>
<span class="sd">        Customized objective function.</span>
<span class="sd">        Should accept two parameters: preds, train_data,</span>
<span class="sd">        and return (grad, hess).</span>

<span class="sd">            preds : list or numpy 1-D array</span>
<span class="sd">                The predicted values.</span>
<span class="sd">                Predicted values are returned before any transformation,</span>
<span class="sd">                e.g. they are raw margin instead of probability of positive class for binary task.</span>
<span class="sd">            train_data : Dataset</span>
<span class="sd">                The training dataset.</span>
<span class="sd">            grad : list or numpy 1-D array</span>
<span class="sd">                The value of the first order derivative (gradient) of the loss</span>
<span class="sd">                with respect to the elements of preds for each sample point.</span>
<span class="sd">            hess : list or numpy 1-D array</span>
<span class="sd">                The value of the second order derivative (Hessian) of the loss</span>
<span class="sd">                with respect to the elements of preds for each sample point.</span>

<span class="sd">        For multi-class task, the preds is group by class_id first, then group by row_id.</span>
<span class="sd">        If you want to get i-th row preds in j-th class, the access way is score[j * num_data + i]</span>
<span class="sd">        and you should group grad and hess in this way as well.</span>

<span class="sd">    feval : callable, list of callable, or None, optional (default=None)</span>
<span class="sd">        Customized evaluation function.</span>
<span class="sd">        Each evaluation function should accept two parameters: preds, train_data,</span>
<span class="sd">        and return (eval_name, eval_result, is_higher_better) or list of such tuples.</span>

<span class="sd">            preds : list or numpy 1-D array</span>
<span class="sd">                The predicted values.</span>
<span class="sd">                If ``fobj`` is specified, predicted values are returned before any transformation,</span>
<span class="sd">                e.g. they are raw margin instead of probability of positive class for binary task in this case.</span>
<span class="sd">            train_data : Dataset</span>
<span class="sd">                The training dataset.</span>
<span class="sd">            eval_name : str</span>
<span class="sd">                The name of evaluation function (without whitespace).</span>
<span class="sd">            eval_result : float</span>
<span class="sd">                The eval result.</span>
<span class="sd">            is_higher_better : bool</span>
<span class="sd">                Is eval result higher better, e.g. AUC is ``is_higher_better``.</span>

<span class="sd">        For multi-class task, the preds is group by class_id first, then group by row_id.</span>
<span class="sd">        If you want to get i-th row preds in j-th class, the access way is preds[j * num_data + i].</span>
<span class="sd">        To ignore the default metric corresponding to the used objective,</span>
<span class="sd">        set ``metrics`` to the string ``&quot;None&quot;``.</span>
<span class="sd">    init_model : str, pathlib.Path, Booster or None, optional (default=None)</span>
<span class="sd">        Filename of LightGBM model or Booster instance used for continue training.</span>
<span class="sd">    feature_name : list of str, or &#39;auto&#39;, optional (default=&quot;auto&quot;)</span>
<span class="sd">        Feature names.</span>
<span class="sd">        If &#39;auto&#39; and data is pandas DataFrame, data columns names are used.</span>
<span class="sd">    categorical_feature : list of str or int, or &#39;auto&#39;, optional (default=&quot;auto&quot;)</span>
<span class="sd">        Categorical features.</span>
<span class="sd">        If list of int, interpreted as indices.</span>
<span class="sd">        If list of str, interpreted as feature names (need to specify ``feature_name`` as well).</span>
<span class="sd">        If &#39;auto&#39; and data is pandas DataFrame, pandas unordered categorical columns are used.</span>
<span class="sd">        All values in categorical features should be less than int32 max value (2147483647).</span>
<span class="sd">        Large values could be memory consuming. Consider using consecutive integers starting from zero.</span>
<span class="sd">        All negative values in categorical features will be treated as missing values.</span>
<span class="sd">        The output cannot be monotonically constrained with respect to a categorical feature.</span>
<span class="sd">    early_stopping_rounds : int or None, optional (default=None)</span>
<span class="sd">        Activates early stopping.</span>
<span class="sd">        CV score needs to improve at least every ``early_stopping_rounds`` round(s)</span>
<span class="sd">        to continue.</span>
<span class="sd">        Requires at least one metric. If there&#39;s more than one, will check all of them.</span>
<span class="sd">        To check only the first metric, set the ``first_metric_only`` parameter to ``True`` in ``params``.</span>
<span class="sd">        Last entry in evaluation history is the one from the best iteration.</span>
<span class="sd">    fpreproc : callable or None, optional (default=None)</span>
<span class="sd">        Preprocessing function that takes (dtrain, dtest, params)</span>
<span class="sd">        and returns transformed versions of those.</span>
<span class="sd">    verbose_eval : bool, int, or None, optional (default=None)</span>
<span class="sd">        Whether to display the progress.</span>
<span class="sd">        If True, progress will be displayed at every boosting stage.</span>
<span class="sd">        If int, progress will be displayed at every given ``verbose_eval`` boosting stage.</span>
<span class="sd">    show_stdv : bool, optional (default=True)</span>
<span class="sd">        Whether to display the standard deviation in progress.</span>
<span class="sd">        Results are not affected by this parameter, and always contain std.</span>
<span class="sd">    seed : int, optional (default=0)</span>
<span class="sd">        Seed used to generate the folds (passed to numpy.random.seed).</span>
<span class="sd">    callbacks : list of callable, or None, optional (default=None)</span>
<span class="sd">        List of callback functions that are applied at each iteration.</span>
<span class="sd">        See Callbacks in Python API for more information.</span>
<span class="sd">    eval_train_metric : bool, optional (default=False)</span>
<span class="sd">        Whether to display the train metric in progress.</span>
<span class="sd">        The score of the metric is calculated again after each training step, so there is some impact on performance.</span>
<span class="sd">    return_cvbooster : bool, optional (default=False)</span>
<span class="sd">        Whether to return Booster models trained on each fold through ``CVBooster``.</span>
<span class="sd">    rum_structure : dict, optional (default=None)</span>
<span class="sd">        List of dictionaries specifying the RUM structure. </span>
<span class="sd">        The list must contain one dictionary for each class, which describes the </span>
<span class="sd">        utility structure for that class. </span>
<span class="sd">        Each dictionary has three allowed keys. </span>

<span class="sd">            cols : list of columns included in that class</span>
<span class="sd">            monotone_constraints : list of monotonic constraints on parameters</span>
<span class="sd">            interaction_constraints : list of interaction constraints on features</span>
<span class="sd">            </span>
<span class="sd">        if None, a biogeme_model must be specified</span>
<span class="sd">    biogeme_model: biogeme.biogeme.BIOGEME, optional (default=None)</span>
<span class="sd">        A biogeme.biogeme.BIOGEME object representing a biogeme model, used to create the rum_structure.</span>
<span class="sd">        A biogeme model is required if rum_structure is None, otherwise should be None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eval_hist : dict</span>
<span class="sd">        Evaluation history.</span>
<span class="sd">        The dictionary has the following format:</span>
<span class="sd">        {&#39;metric1-mean&#39;: [values], &#39;metric1-stdv&#39;: [values],</span>
<span class="sd">        &#39;metric2-mean&#39;: [values], &#39;metric2-stdv&#39;: [values],</span>
<span class="sd">        ...}.</span>
<span class="sd">        If ``return_cvbooster=True``, also returns trained boosters via ``cvbooster`` key.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Training only accepts Dataset object&quot;</span><span class="p">)</span>

    <span class="n">params</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fobj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">obj_alias</span> <span class="ow">in</span> <span class="n">_ConfigAliases</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;objective&quot;</span><span class="p">):</span>
            <span class="n">params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">obj_alias</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">params</span><span class="p">[</span><span class="s1">&#39;objective&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
    <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">_ConfigAliases</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;num_iterations&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">_log_warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found `</span><span class="si">{</span><span class="n">alias</span><span class="si">}</span><span class="s2">` in params. Will use it instead of argument&quot;</span><span class="p">)</span>
            <span class="n">num_boost_round</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
    <span class="n">params</span><span class="p">[</span><span class="s2">&quot;num_iterations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_boost_round</span>
    <span class="k">if</span> <span class="n">early_stopping_rounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">early_stopping_rounds</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">_log_warning</span><span class="p">(</span><span class="s2">&quot;&#39;early_stopping_rounds&#39; argument is deprecated and will be removed in a future release of LightGBM. &quot;</span>
                     <span class="s2">&quot;Pass &#39;early_stopping()&#39; callback via &#39;callbacks&#39; argument instead.&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">_ConfigAliases</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;early_stopping_round&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">early_stopping_rounds</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
    <span class="n">params</span><span class="p">[</span><span class="s2">&quot;early_stopping_round&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">early_stopping_rounds</span>
    <span class="n">first_metric_only</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;first_metric_only&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_boost_round</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_boost_round should be greater than zero.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_model</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">)):</span>
        <span class="n">predictor</span> <span class="o">=</span> <span class="n">_InnerPredictor</span><span class="p">(</span><span class="n">model_file</span><span class="o">=</span><span class="n">init_model</span><span class="p">,</span> <span class="n">pred_parameter</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_model</span><span class="p">,</span> <span class="n">Booster</span><span class="p">):</span>
        <span class="n">predictor</span> <span class="o">=</span> <span class="n">init_model</span><span class="o">.</span><span class="n">_to_predictor</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">init_model</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">predictor</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">metric_alias</span> <span class="ow">in</span> <span class="n">_ConfigAliases</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;metric&quot;</span><span class="p">):</span>
            <span class="n">params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">metric_alias</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">params</span><span class="p">[</span><span class="s1">&#39;metric&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">metrics</span>

    <span class="n">train_set</span><span class="o">.</span><span class="n">_update_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> \
             <span class="o">.</span><span class="n">_set_predictor</span><span class="p">(</span><span class="n">predictor</span><span class="p">)</span> \
             <span class="o">.</span><span class="n">set_feature_name</span><span class="p">(</span><span class="n">feature_name</span><span class="p">)</span> \
             <span class="o">.</span><span class="n">set_categorical_feature</span><span class="p">(</span><span class="n">categorical_feature</span><span class="p">)</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">cvfolds</span> <span class="o">=</span> <span class="n">_make_n_folds</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="n">folds</span><span class="o">=</span><span class="n">folds</span><span class="p">,</span> <span class="n">nfold</span><span class="o">=</span><span class="n">nfold</span><span class="p">,</span>
                            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">fpreproc</span><span class="o">=</span><span class="n">fpreproc</span><span class="p">,</span>
                            <span class="n">stratified</span><span class="o">=</span><span class="n">stratified</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span>
                            <span class="n">eval_train_metric</span><span class="o">=</span><span class="n">eval_train_metric</span><span class="p">,</span> <span class="n">rum_structure</span><span class="o">=</span><span class="n">rum_structure</span><span class="p">,</span>
                            <span class="n">biogeme_model</span><span class="o">=</span><span class="n">biogeme_model</span><span class="p">)</span>

    <span class="c1"># setup callbacks</span>
    <span class="k">if</span> <span class="n">callbacks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">callbacks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">callbacks</span><span class="p">):</span>
            <span class="n">cb</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">callbacks</span><span class="p">))</span>
        <span class="n">callbacks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">callbacks</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">early_stopping_rounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">early_stopping_rounds</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">callbacks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">callback</span><span class="o">.</span><span class="n">early_stopping</span><span class="p">(</span><span class="n">early_stopping_rounds</span><span class="p">,</span> <span class="n">first_metric_only</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">verbose_eval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_log_warning</span><span class="p">(</span><span class="s2">&quot;&#39;verbose_eval&#39; argument is deprecated and will be removed in a future release of LightGBM. &quot;</span>
                     <span class="s2">&quot;Pass &#39;log_evaluation()&#39; callback via &#39;callbacks&#39; argument instead.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose_eval</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">callbacks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">callback</span><span class="o">.</span><span class="n">log_evaluation</span><span class="p">(</span><span class="n">show_stdv</span><span class="o">=</span><span class="n">show_stdv</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">verbose_eval</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">callbacks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">callback</span><span class="o">.</span><span class="n">log_evaluation</span><span class="p">(</span><span class="n">verbose_eval</span><span class="p">,</span> <span class="n">show_stdv</span><span class="o">=</span><span class="n">show_stdv</span><span class="p">))</span>

    <span class="n">callbacks_before_iter</span> <span class="o">=</span> <span class="p">{</span><span class="n">cb</span> <span class="k">for</span> <span class="n">cb</span> <span class="ow">in</span> <span class="n">callbacks</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="s1">&#39;before_iteration&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)}</span>
    <span class="n">callbacks_after_iter</span> <span class="o">=</span> <span class="n">callbacks</span> <span class="o">-</span> <span class="n">callbacks_before_iter</span>
    <span class="n">callbacks_before_iter</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">callbacks_before_iter</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">))</span>
    <span class="n">callbacks_after_iter</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">callbacks_after_iter</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_boost_round</span><span class="p">):</span>
        <span class="n">cross_ent</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">raw_results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#train all RUMBoosts</span>
        <span class="k">for</span> <span class="n">RUMBoost</span> <span class="ow">in</span> <span class="n">cvfolds</span><span class="o">.</span><span class="n">RUMBoosts</span><span class="p">:</span>
            <span class="n">RUMBoost</span><span class="o">.</span><span class="n">_preds</span> <span class="o">=</span> <span class="n">RUMBoost</span><span class="o">.</span><span class="n">_inner_predict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">booster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">RUMBoost</span><span class="o">.</span><span class="n">boosters</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">cb</span> <span class="ow">in</span> <span class="n">callbacks_before_iter</span><span class="p">:</span>
                    <span class="n">cb</span><span class="p">(</span><span class="n">callback</span><span class="o">.</span><span class="n">CallbackEnv</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">booster</span><span class="p">,</span>
                                            <span class="n">params</span><span class="o">=</span><span class="n">RUMBoost</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                                            <span class="n">iteration</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                                            <span class="n">begin_iteration</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                            <span class="n">end_iteration</span><span class="o">=</span><span class="n">num_boost_round</span><span class="p">,</span>
                                            <span class="n">evaluation_result_list</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
                <span class="n">RUMBoost</span><span class="o">.</span><span class="n">_current_j</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">booster</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">train_set</span> <span class="o">=</span> <span class="n">RUMBoost</span><span class="o">.</span><span class="n">train_set</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">fobj</span><span class="o">=</span><span class="n">RUMBoost</span><span class="o">.</span><span class="n">f_obj</span><span class="p">)</span>

            <span class="n">valid_sets</span> <span class="o">=</span> <span class="n">RUMBoost</span><span class="o">.</span><span class="n">valid_sets</span>
            <span class="k">for</span> <span class="n">valid_set</span> <span class="ow">in</span> <span class="n">valid_sets</span><span class="p">:</span>
                <span class="n">preds_valid</span> <span class="o">=</span> <span class="n">RUMBoost</span><span class="o">.</span><span class="n">_inner_predict</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">valid_set</span><span class="p">)</span>
                <span class="n">raw_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">preds_valid</span><span class="p">)</span>
                <span class="n">cross_ent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">RUMBoost</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="n">preds_valid</span><span class="p">,</span> <span class="n">valid_set</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)))</span>

        <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;Cross entropy --- mean&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cross_ent</span><span class="p">))</span>
        <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;Cross entropy --- stdv&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">cross_ent</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose_eval</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">{}</span><span class="s1">] -- Cross entropy mean: </span><span class="si">{}</span><span class="s1">, with std: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cross_ent</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">cross_ent</span><span class="p">)))</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cross_ent</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cvfolds</span><span class="o">.</span><span class="n">best_score</span><span class="p">:</span>
            <span class="n">cvfolds</span><span class="o">.</span><span class="n">best_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cross_ent</span><span class="p">)</span>
            <span class="n">cvfolds</span><span class="o">.</span><span class="n">best_iteration</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> 

        <span class="k">if</span> <span class="n">early_stopping_rounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cvfolds</span><span class="o">.</span><span class="n">best_iteration</span> <span class="o">+</span> <span class="n">early_stopping_rounds</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Early stopping at iteration </span><span class="si">{}</span><span class="s1"> with a cross entropy best score of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cvfolds</span><span class="o">.</span><span class="n">best_iteration</span><span class="p">,</span><span class="n">cvfolds</span><span class="o">.</span><span class="n">best_score</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">k</span><span class="p">][:</span><span class="n">cvfolds</span><span class="o">.</span><span class="n">best_iteration</span><span class="p">]</span>
            <span class="k">break</span>
        <span class="c1">#res = _agg_cv_result(raw_results, eval_train_metric)</span>
        <span class="c1">#try:</span>
        <span class="c1">#    for cb in callbacks_after_iter:</span>
        <span class="c1">#        cb(callback.CallbackEnv(model=cvfolds,</span>
        <span class="c1">#                                params=params,</span>
        <span class="c1">#                                iteration=i,</span>
        <span class="c1">#                                begin_iteration=0,</span>
        <span class="c1">#                                end_iteration=num_boost_round,</span>
        <span class="c1">#                                evaluation_result_list=res))</span>
        <span class="c1">#except callback.EarlyStopException as earlyStopException:</span>
        <span class="c1">#    cvfolds.best_iteration = earlyStopException.best_iteration + 1</span>
        <span class="c1">#    for k in results:</span>
        <span class="c1">#        results[k] = results[k][:cvfolds.best_iteration]</span>
        <span class="c1">#    break</span>

    <span class="k">if</span> <span class="n">return_cvbooster</span><span class="p">:</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;cvbooster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cvfolds</span>

    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Nicolas Salvadé, Tim Hillel.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>